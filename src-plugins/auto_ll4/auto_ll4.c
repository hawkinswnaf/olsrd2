
/*
 * The olsr.org Optimized Link-State Routing daemon version 2 (olsrd2)
 * Copyright (c) 2004-2013, the olsr.org team - see HISTORY file
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 *
 * * Redistributions of source code must retain the above copyright
 *   notice, this list of conditions and the following disclaimer.
 * * Redistributions in binary form must reproduce the above copyright
 *   notice, this list of conditions and the following disclaimer in
 *   the documentation and/or other materials provided with the
 *   distribution.
 * * Neither the name of olsr.org, olsrd nor the names of its
 *   contributors may be used to endorse or promote products derived
 *   from this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
 * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
 * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
 * FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE
 * COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,
 * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
 * BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
 * CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN
 * ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
 * POSSIBILITY OF SUCH DAMAGE.
 *
 * Visit http://www.olsr.org for more information.
 *
 * If you find this software useful feel free to make a donation
 * to the project. For more information see the website or contact
 * the copyright holders.
 *
 */

#include <errno.h>
#include <stdio.h>

#include "common/common_types.h"
#include "common/autobuf.h"
#include "common/avl.h"
#include "config/cfg_schema.h"
#include "core/oonf_cfg.h"
#include "core/oonf_logging.h"
#include "core/oonf_plugins.h"
#include "core/os_core.h"
#include "subsystems/oonf_class.h"
#include "subsystems/oonf_clock.h"
#include "subsystems/oonf_interface.h"
#include "subsystems/oonf_timer.h"
#include "subsystems/os_system.h"

#include "nhdp/nhdp.h"
#include "nhdp/nhdp_domain.h"
#include "nhdp/nhdp_interfaces.h"

#include "auto_ll4/auto_ll4.h"

/* constants and definitions */
struct _config {
  uint64_t startup_delay;
};

#define _MODE_DETECT "detect"

enum _auto_ll4_mode {
  _AUTO_LL4_DETECT,
  _AUTO_LL4_ON,
  _AUTO_LL4_OFF,
};

struct _nhdp_if_autoll4 {
  /* timer until next update of autogenerated ip */
  struct oonf_timer_entry update_timer;

  /* true if the node is still in the initial update_timer phase */
  bool startup;

  /* true if interface LL4 is handled by this plugin */
  bool active;

  /* data structure for setting and resetting autoconfigured address */
  struct os_system_address os_addr;

  /* currently configured address */
  struct netaddr auto_ll4_addr;
};

/* prototypes */
static int _init(void);
static void _initiate_shutdown(void);
static void _cleanup(void);

static void _cleanup_nhdp_if_extension(struct nhdp_interface *nhdp_if);
static void _cb_check_addresses(void *);
static void _cb_add_nhdp_interface(void *);
static void _cb_remove_nhdp_interface(void *);
static void _cb_address_finished(struct os_system_address *, int);
static void _commit_address(struct _nhdp_if_autoll4 *auto_ll4);
static void _change_mode(struct nhdp_interface *nhdp_if,
    enum _auto_ll4_mode new_mode);
uint16_t _calculate_host_part(const char *key, size_t len);
static bool _is_address_collision(
    struct netaddr *auto_ll4, uint16_t hash, struct netaddr *addr);
static bool _nhdp_if_has_collision(
    struct nhdp_interface *nhdp_if, struct netaddr *addr, uint16_t hash);
static void _generate_address(struct nhdp_interface *nhdp_if,
    struct _nhdp_if_autoll4 *auto_ll4);
static void _cb_laddr_change(void *);
static void _cb_2hop_change(void *);
static void _cb_ll4_cfg_changed(void);
static void _cb_if_cfg_changed(void);

/* plugin declaration */
static const char *_ll4_modes[] = {
  _MODE_DETECT, CFGLIST_BOOL_VALUES,
};

static struct cfg_schema_entry _if_entries[] = {
  CFG_VALIDATE_CHOICE("auto_ll4", _MODE_DETECT,
      "Controls autogeneration of IPv4 linklocal IPs on interface."
      " Set to '" _MODE_DETECT "' to automatically detect existing address on interface,"
      " use boolean values to set on/off",
      _ll4_modes),
};

static struct cfg_schema_section _if_section = {
  .type = CFG_INTERFACE_SECTION,
  .mode = CFG_INTERFACE_SECTION_MODE,
  .cb_delta_handler = _cb_if_cfg_changed,
  .entries = _if_entries,
  .entry_count = ARRAYSIZE(_if_entries),
};

static struct cfg_schema_entry _auto_ll4_entries[] = {
  CFG_MAP_CLOCK(_config, startup_delay, "startup", "10",
      "Startup time until first autoconfigured IPv4 linklocal should be selected."),
};

static struct cfg_schema_section _auto_ll4_section = {
  .type = OONF_PLUGIN_GET_NAME(),
  .mode = CFG_SSMODE_UNNAMED,
  .cb_delta_handler = _cb_ll4_cfg_changed,
  .entries = _auto_ll4_entries,
  .entry_count = ARRAYSIZE(_auto_ll4_entries),
  .next_section = &_if_section,
};

struct oonf_subsystem olsrv2_auto_ll4_subsystem = {
  .name = OONF_PLUGIN_GET_NAME(),
  .descr = "OLSRv2 Funkfeuer Automatic IPv4 Linklayer IP generation plugin",
  .author = "Henning Rogge",

  .cfg_section = &_auto_ll4_section,

  .init = _init,
  .cleanup = _cleanup,
  .initiate_shutdown = _initiate_shutdown,
};
DECLARE_OONF_PLUGIN(olsrv2_auto_ll4_subsystem);

/* timer for handling new NHDP neighbors */
static struct oonf_timer_info _startup_timer_info = {
  .name = "Initial delay until first IPv4 linklocal IPs are generated",
  .callback = _cb_check_addresses,
  .periodic = false,
};

/* NHDP interface extension/listener */
static struct oonf_class_extension _nhdp_if_extenstion = {
  .name = "auto ll4 generation",
  .class_name = NHDP_CLASS_INTERFACE,
  .size = sizeof(struct _nhdp_if_autoll4),

  .cb_add = _cb_add_nhdp_interface,
  .cb_remove = _cb_remove_nhdp_interface,
};

/* NHDP link address listener */
static struct oonf_class_extension _nhdp_laddr_listener = {
  .name = "auto ll4 generation",
  .class_name = NHDP_CLASS_LINK_ADDRESS,

  .cb_add = _cb_laddr_change,
  .cb_remove = _cb_laddr_change,
};

/* NHDP twohop listener */
static struct oonf_class_extension _nhdp_2hop_listener = {
  .name = "auto ll4 generation",
  .class_name = NHDP_CLASS_LINK_2HOP,

  .cb_add = _cb_2hop_change,
  .cb_remove = _cb_2hop_change,
};

/* global variables */
static uint64_t _ll4_startup_delay = 10*1000;

/**
 * Initialize plugin
 * @return -1 if an error happened, 0 otherwise
 */
static int
_init(void) {
  if (oonf_class_extension_add(&_nhdp_if_extenstion)) {
    OONF_WARN(LOG_AUTO_LL4, "Cannot allocate extension for NHDP interface data");
    return -1;
  }

  oonf_class_extension_add(&_nhdp_laddr_listener);
  oonf_class_extension_add(&_nhdp_2hop_listener);
  oonf_timer_add(&_startup_timer_info);
  return 0;
}

static void
_initiate_shutdown(void) {
  struct nhdp_interface *nhdp_if;

  avl_for_each_element(&nhdp_interface_tree, nhdp_if, _node) {
    _cleanup_nhdp_if_extension(nhdp_if);
  }
}

/**
 * Cleanup plugin
 */
static void
_cleanup(void) {
  oonf_class_extension_remove(&_nhdp_2hop_listener);
  oonf_class_extension_remove(&_nhdp_laddr_listener);
  oonf_class_extension_remove(&_nhdp_if_extenstion);

  oonf_timer_remove(&_startup_timer_info);
}

static void
_cleanup_nhdp_if_extension(struct nhdp_interface *nhdp_if) {
  struct _nhdp_if_autoll4 *auto_ll4;

  /* get auto linklayer extension */
  auto_ll4 = oonf_class_get_extension(&_nhdp_if_extenstion, nhdp_if);

  /* stop running address setting feedback */
  auto_ll4->os_addr.cb_finished = NULL;
  os_system_ifaddr_interrupt(&auto_ll4->os_addr);

  /* cleanup */
  netaddr_invalidate(&auto_ll4->auto_ll4_addr);
  if (auto_ll4->active) {
    _commit_address(auto_ll4);
  }
  netaddr_invalidate(&auto_ll4->os_addr.address);
  auto_ll4->active = false;

  oonf_timer_stop(&auto_ll4->update_timer);
}

static void
_cb_check_addresses(void *ptr) {
  struct nhdp_interface *nhdp_if;
  struct _nhdp_if_autoll4 *auto_ll4;

  /* get auto linklayer extension */
  nhdp_if = ptr;
  auto_ll4 = oonf_class_get_extension(&_nhdp_if_extenstion, nhdp_if);

  OONF_DEBUG(LOG_AUTO_LL4, "Trigger processing of autoconfigured address");

  /* not startup anymore */
  auto_ll4->startup = false;

  /* trigger address recalculation */
  if (auto_ll4->active) {
    _change_mode(nhdp_if, _AUTO_LL4_ON);
  }
  else {
    _change_mode(nhdp_if, _AUTO_LL4_OFF);
  }
}

static void
_cb_add_nhdp_interface(void *ptr) {
  struct nhdp_interface *nhdp_if;
  struct _nhdp_if_autoll4 *auto_ll4;

  /* get auto linklayer extension */
  nhdp_if = ptr;
  auto_ll4 = oonf_class_get_extension(&_nhdp_if_extenstion, nhdp_if);

  /* initialize static part of routing data */
  auto_ll4->os_addr.cb_finished = _cb_address_finished;
  auto_ll4->os_addr.if_index = nhdp_interface_get_coreif(nhdp_if)->data.index;
  auto_ll4->os_addr.scope = OS_ADDR_SCOPE_LINK;

  /* activate update_timer delay timer */
  auto_ll4->update_timer.info = &_startup_timer_info;
  auto_ll4->update_timer.cb_context = nhdp_if;
  auto_ll4->startup = true;
  oonf_timer_set(&auto_ll4->update_timer, _ll4_startup_delay);
}

static void
_cb_remove_nhdp_interface(void *ptr) {
  _cleanup_nhdp_if_extension(ptr);
}

static void
_cb_address_finished(struct os_system_address *os_addr, int error) {
  struct _nhdp_if_autoll4 *auto_ll4;
  struct netaddr_str nbuf;
  char ibuf[IF_NAMESIZE];

  /* get auto linklayer extension */
  auto_ll4 = container_of(os_addr, typeof(*auto_ll4), os_addr);

  OONF_DEBUG(LOG_AUTO_LL4, "Got feedback from netlink for %s address %s on if %s: %s (%d)",
      os_addr->set ? "setting" : "resetting",
          netaddr_to_string(&nbuf, &os_addr->address),
          if_indextoname(os_addr->if_index, ibuf),
          strerror(error), error);

  if (error) {
    if ((os_addr->set && error != EEXIST)
        || (!os_addr->set && error != EADDRNOTAVAIL)) {
      /* try again */
      oonf_timer_set(&auto_ll4->update_timer, 1000);
      netaddr_invalidate(&os_addr->address);
      return;
    }
  }

  if (!os_addr->set) {
    /* address was successfully removed, so clear the data too */
    netaddr_invalidate(&os_addr->address);
  }

  /* make sure we are done */
  oonf_timer_set(&auto_ll4->update_timer, 1);
}

static void
_commit_address(struct _nhdp_if_autoll4 *auto_ll4) {
  struct netaddr_str nbuf;
  char ibuf[IF_NAMESIZE];

  if (netaddr_cmp(&auto_ll4->os_addr.address, &auto_ll4->auto_ll4_addr) == 0) {
    /* nothing to do */
    OONF_DEBUG(LOG_AUTO_LL4, "Nothing to do, address is already in place");
    return;
  }

  if (netaddr_get_address_family(&auto_ll4->os_addr.address) == AF_UNSPEC) {
    /* set new address */
    memcpy(&auto_ll4->os_addr.address, &auto_ll4->auto_ll4_addr,
        sizeof(struct netaddr));
    auto_ll4->os_addr.set = true;

    OONF_DEBUG(LOG_AUTO_LL4, "Set address %s on interface %s",
        netaddr_to_string(&nbuf, &auto_ll4->os_addr.address),
        if_indextoname(auto_ll4->os_addr.if_index, ibuf));
  }
  else {
    /* remove address (and maybe set another one afterwards */
    auto_ll4->os_addr.set = false;

    OONF_DEBUG(LOG_AUTO_LL4, "Reset address %s on interface %s",
        netaddr_to_string(&nbuf, &auto_ll4->os_addr.address),
        if_indextoname(auto_ll4->os_addr.if_index, ibuf));
  }
  os_system_ifaddr_set(&auto_ll4->os_addr);
}

static void
_change_mode(struct nhdp_interface *nhdp_if, enum _auto_ll4_mode new_mode) {
  struct oonf_interface_data *ifdata;
  struct _nhdp_if_autoll4 *auto_ll4;
  size_t i;

  /* get pointer to interface data */
  ifdata = &(nhdp_interface_get_coreif(nhdp_if)->data);

  /* get auto linklayer extension */
  auto_ll4 = oonf_class_get_extension(&_nhdp_if_extenstion, nhdp_if);

  /* ignore loopback */
  if (ifdata->loopback) {
    auto_ll4->active = false;
    return;
  }

  if (new_mode == _AUTO_LL4_DETECT
      && netaddr_get_address_family(&auto_ll4->os_addr.address) == AF_UNSPEC) {

    /* run autodetection */
    auto_ll4->active = true;

    for (i=0; i<ifdata->addrcount; i++) {
      if (netaddr_get_address_family(&ifdata->addresses[i]) == AF_INET) {
        /* there is already an address */
        auto_ll4->active = false;
        break;
      }
    }
  }
  else if (new_mode == _AUTO_LL4_ON) {
    auto_ll4->active = true;
  }
  else {
    auto_ll4->active = false;
  }

  OONF_DEBUG(LOG_AUTO_LL4, "%s autoconfigred address on interface %s",
      auto_ll4->active ? "Set" : "Reset", ifdata->name);

  if (!auto_ll4->active) {
    /* remove current address if there is one */
    netaddr_invalidate(&auto_ll4->auto_ll4_addr);
    _commit_address(auto_ll4);
  }
  else {
    /* generate an IPv4 linklocal address */
    _generate_address(nhdp_if, auto_ll4);
  }
}

uint16_t
_calculate_host_part(const char *key, size_t len)
{
  uint32_t hash, i;

  /* step 1: calculate Jenkins hash */
  for(hash = i = 0; i < len; ++i)
  {
    hash += key[i];
    hash += (hash << 10);
    hash ^= (hash >> 6);
  }
  hash += (hash << 3);
  hash ^= (hash >> 11);
  hash += (hash << 15);

  /* step 2: calculate host part of linklocal address */
  return htons((hash % (254 * 256)) + 256);
}

static bool
_is_address_collision(struct netaddr *auto_ll4, uint16_t hash, struct netaddr *addr) {
  if (netaddr_get_address_family(addr) == AF_INET) {
    if (netaddr_cmp(auto_ll4, addr) == 0) {
      return true;
    }
  }
  else if(hash == _calculate_host_part(
      netaddr_get_binptr(addr), netaddr_get_binlength(addr))) {
    return true;
  }

  return false;
}

static bool
_nhdp_if_has_collision(struct nhdp_interface *nhdp_if, struct netaddr *addr, uint16_t hash) {
  struct nhdp_link *lnk;
  struct nhdp_laddr *laddr;
  struct nhdp_l2hop *l2hop;

  list_for_each_element(&nhdp_if->_links, lnk, _if_node) {
    /* check for collision with one-hop neighbor */
    avl_for_each_element(&lnk->_addresses, laddr, _link_node) {
      if (_is_address_collision(addr, hash, &laddr->link_addr)) {
        return true;
      }
    }

    avl_for_each_element(&lnk->_2hop, l2hop, _link_node) {
      if (_is_address_collision(addr, hash, &l2hop->twohop_addr)) {
        return true;
      }
    }
  }
  return false;
}

static void
_generate_address(struct nhdp_interface *nhdp_if,
    struct _nhdp_if_autoll4 *auto_ll4) {
  struct oonf_interface_data *ifdata;
  const struct netaddr *ll_ipv6;
  uint16_t hash;
  struct netaddr_str nbuf;

  ifdata = &nhdp_interface_get_coreif(nhdp_if)->data;
  ll_ipv6 = ifdata->linklocal_v6_ptr;

  if (netaddr_get_address_family(&auto_ll4->auto_ll4_addr) == AF_UNSPEC) {
    /* generate a new address from the IPv6 linklocal address */
    hash = _calculate_host_part(
        netaddr_get_binptr(ll_ipv6), netaddr_get_binlength(ll_ipv6));

    /*
     * generate the address between
     * 169.254.1.0/16 and 169.254.254.255/16
     */
    netaddr_create_host_bin(&auto_ll4->auto_ll4_addr, &NETADDR_IPV4_LINKLOCAL,
        &hash, sizeof(hash));
    netaddr_set_prefix_length(&auto_ll4->auto_ll4_addr, 16);
  }

  OONF_DEBUG(LOG_AUTO_LL4, "See if %s is a good autoconfigured address for interface %s",
      netaddr_to_string(&nbuf, &auto_ll4->auto_ll4_addr), ifdata->name);

  /* check for collisions */
  while (_nhdp_if_has_collision(nhdp_if, &auto_ll4->auto_ll4_addr, hash)) {
    /* roll up a random address */
    hash = htons((os_core_random() % (256 * 254)) + 256);
    netaddr_create_host_bin(&auto_ll4->auto_ll4_addr, &NETADDR_IPV4_LINKLOCAL,
        &hash, sizeof(hash));
    OONF_DEBUG(LOG_AUTO_LL4, "Collision, randomizing address!"
        " See if %s is a good autoconfigured address for interface %s",
        netaddr_to_string(&nbuf, &auto_ll4->auto_ll4_addr), ifdata->name);
  }

  /* set address */
  _commit_address(auto_ll4);
}

static void
_cb_laddr_change(void *ptr) {
  struct nhdp_laddr *laddr;
  struct nhdp_interface *nhdp_if;
  struct _nhdp_if_autoll4 *auto_ll4;

  laddr = ptr;
  nhdp_if = laddr->link->local_if;
  auto_ll4 = oonf_class_get_extension(&_nhdp_if_extenstion, nhdp_if);

  if (!oonf_timer_is_active(&auto_ll4->update_timer)) {
    /* request delayed address check */
    oonf_timer_set(&auto_ll4->update_timer, 1);
  }
}

static void
_cb_2hop_change(void *ptr) {
  struct nhdp_l2hop *l2hop;
  struct nhdp_interface *nhdp_if;
  struct _nhdp_if_autoll4 *auto_ll4;

  l2hop = ptr;
  nhdp_if = l2hop->link->local_if;
  auto_ll4 = oonf_class_get_extension(&_nhdp_if_extenstion, nhdp_if);

  if (!oonf_timer_is_active(&auto_ll4->update_timer)) {
    /* request delayed address check */
    oonf_timer_set(&auto_ll4->update_timer, 1);
  }
}

/**
 * Callback triggered when configuration changes
 */
static void
_cb_ll4_cfg_changed(void) {
  struct nhdp_interface *nhdp_if;
  struct _nhdp_if_autoll4 *auto_ll4;
  struct _config cfg;

  memset(&cfg, 0, sizeof(cfg));
  if (cfg_schema_tobin(&cfg, _auto_ll4_section.post,
      _auto_ll4_entries, ARRAYSIZE(_auto_ll4_entries))) {
    OONF_WARN(LOG_AUTO_LL4, "Cannot convert plugin configuration.");
    return;
  }

  if (cfg.startup_delay == _ll4_startup_delay) {
    return;
  }

  avl_for_each_element(&nhdp_interface_tree, nhdp_if, _node) {
    /* get auto linklayer extension */
    auto_ll4 = oonf_class_get_extension(&_nhdp_if_extenstion, nhdp_if);

    /* fix update_timer timer if still running */
    if (auto_ll4->startup) {
      oonf_timer_set(&auto_ll4->update_timer, _ll4_startup_delay);
    }
  }
}

static void
_cb_if_cfg_changed(void) {
  struct nhdp_interface *nhdp_if;
  const struct const_strarray *strarray;
  enum _auto_ll4_mode new_mode;

  /* make sure interface exists */
  nhdp_if = nhdp_interface_add(_if_section.section_name);
  if (nhdp_if == NULL) {
    return;
  }

  /* get new interface mode */
  strarray = cfg_schema_tovalue(_if_section.post, &_if_entries[0]);
  if (strcasecmp(_MODE_DETECT, strarray->value) == 0) {
    new_mode = _AUTO_LL4_DETECT;
  }
  else if(cfg_get_bool(strarray->value)) {
    new_mode = _AUTO_LL4_ON;
  }
  else {
    new_mode = _AUTO_LL4_OFF;
  }

  _change_mode(nhdp_if, new_mode);
}
